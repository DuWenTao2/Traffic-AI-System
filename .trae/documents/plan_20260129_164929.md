# 基于车道线几何关系的区域生成器参数配置方案

## 1. 创建配置文件

在 `Models/Config` 文件夹中创建 `lane_based_region_generator_config.json` 文件，包含以下参数：

```json
{
  "description": "基于车道线几何关系的区域生成器配置文件",
  "version": "1.0",
  "date": "2026-01-30",
  "parameters": {
    "# 基本参数": "",
    "generation_interval": 2.0,
    "region_update_interval": 5.0,
    
    "# 消失点计算参数": "",
    "lane_extension_factor": 10.0,
    
    "# 车道宽度计算参数": "",
    "default_lane_width": 100,
    
    "# 应急车道识别参数": "",
    "emergency_lane_width_threshold": 1.2,
    
    "# 速度检测线生成参数": "",
    "speed_line_count": 5,
    "speed_line_spacing_factor": 6,
    
    "# 区域更新参数": "",
    "region_update_enabled": true
  }
}
```

## 2. 修改 lane_based_region_generator.py 文件

### 2.1 添加配置文件加载功能

在 `LaneBasedRegionGenerator` 类的 `__init__` 方法中添加配置文件加载功能：

```python
def __init__(self, stream_id="default"):
    self.stream_id = stream_id
    self.lane_analyzer = LaneAnalyzer()
    self.last_generation_time = 0
    
    # 1. 设置代码默认值
    self._set_default_parameters()
    
    # 2. 从配置文件加载参数
    self._load_config_parameters()
    
    print(f"[{self.stream_id}] Lane-based region generator initialized with parameters loaded")
```

### 2.2 添加默认参数设置方法

添加 `_set_default_parameters` 方法：

```python
def _set_default_parameters(self):
    """设置代码默认参数"""
    # 基本参数
    self.generation_interval = 2.0  # 生成间隔，避免频繁计算
    self.region_update_interval = 5.0  # 区域更新间隔
    
    # 消失点计算参数
    self.lane_extension_factor = 10.0  # 车道线延长系数
    
    # 车道宽度计算参数
    self.default_lane_width = 100  # 默认车道宽度（像素）
    
    # 应急车道识别参数
    self.emergency_lane_width_threshold = 1.2  # 应急车道宽度阈值
    
    # 速度检测线生成参数
    self.speed_line_count = 5  # 速度检测线数量
    self.speed_line_spacing_factor = 6  # 速度检测线间距因子
    
    # 区域更新参数
    self.region_update_enabled = True  # 是否启用区域更新
```

### 2.3 添加配置文件加载方法

添加 `_load_config_parameters` 方法：

```python
def _load_config_parameters(self):
    """从配置文件加载参数"""
    import os
    import json
    
    # 配置文件路径
    config_path = os.path.join(os.path.dirname(__file__), "..", "Config", "lane_based_region_generator_config.json")
    config_path = os.path.abspath(config_path)
    
    if os.path.exists(config_path):
        try:
            with open(config_path, 'r', encoding='utf-8') as f:
                config = json.load(f)
            
            # 加载参数
            if 'parameters' in config:
                params = config['parameters']
                # 跳过注释键（以#开头的键）
                for key, value in params.items():
                    if not key.startswith('#') and hasattr(self, key):
                        setattr(self, key, value)
                print(f"[{self.stream_id}] Lane-based region generator parameters loaded from config file")
        except Exception as e:
            print(f"[{self.stream_id}] Error loading config file: {str(e)}")
    else:
        print(f"[{self.stream_id}] Config file not found at {config_path}, using default parameters")
```

### 2.4 修改相关方法使用配置参数

修改 `_generate_speed_lines` 方法，使用配置参数：

```python
def _generate_speed_lines(self):
    """生成速度检测线"""
    speed_lines = []
    
    if not self.lane_analyzer.lane_lines or not self.lane_analyzer.frame_shape:
        return speed_lines
    
    # 计算平均车道宽度
    avg_lane_width = np.mean(self.lane_analyzer.lane_widths) if self.lane_analyzer.lane_widths else self.default_lane_width
    
    # 在图像垂直方向均匀分布速度线
    # 从图像底部向上生成，覆盖主要的车辆行驶区域
    height = self.lane_analyzer.frame_shape[0]
    width = self.lane_analyzer.frame_shape[1]
    
    # 生成指定数量的速度线
    for i in range(self.speed_line_count):
        # 计算速度线的y坐标
        y = height - int((i + 1) * height / self.speed_line_spacing_factor)
        
        # 找到最左侧和最右侧的车道线
        leftmost_x = 0
        rightmost_x = width
        
        for lane in self.lane_analyzer.lane_lines:
            points = lane['points']
            if len(points) == 2:
                # 计算车道线在当前y坐标的x值
                x = self.lane_analyzer._get_lane_x_at_y(lane, y)
                if x is not None:
                    leftmost_x = max(leftmost_x, x - avg_lane_width)
                    rightmost_x = min(rightmost_x, x + avg_lane_width)
        
        # 创建速度线
        if leftmost_x < rightmost_x:
            speed_lines.append({
                'points': [(int(leftmost_x), int(y)), (int(rightmost_x), int(y))],
                'type': 'SPEED',
                'enabled': True,
                'properties': {}
            })
    
    return speed_lines
```

修改 `LaneAnalyzer` 类的 `_calculate_vanishing_point` 方法，使用配置参数：

```python
def _calculate_vanishing_point(self):
    """计算消失点"""
    if len(self.lane_lines) < 2 or not self.frame_shape:
        return
    
    # 收集所有车道线的延长线
    extended_lines = []
    for lane in self.lane_lines:
        points = lane['points']
        if len(points) == 2:
            # 延长车道线到图像顶部
            p1 = np.array(points[0])
            p2 = np.array(points[1])
            # 计算参数方程
            t = -p1[1] / (p2[1] - p1[1]) if (p2[1] - p1[1]) != 0 else self.lane_extension_factor
            extended_p = p1 + t * (p2 - p1)
            extended_lines.append((p1, extended_p))
    
    # 计算所有延长线的交点区域
    intersections = []
    for i in range(len(extended_lines)):
        for j in range(i+1, len(extended_lines)):
            p1, p2 = extended_lines[i]
            p3, p4 = extended_lines[j]
            # 计算两直线交点
            intersection = self._line_intersection(p1, p2, p3, p4)
            if intersection is not None:
                intersections.append(intersection)
    
    # 计算交点的平均值作为消失点
    if intersections:
        self.vanishing_point = np.mean(intersections, axis=0)
```

修改 `LaneAnalyzer` 类的 `_identify_emergency_lane` 方法，使用配置参数：

```python
def _identify_emergency_lane(self):
    """识别应急车道"""
    if len(self.lane_lines) < 1:
        return
    
    # 按车道线在图像底部的x坐标排序
    lane_positions = []
    for i, lane in enumerate(self.lane_lines):
        bottom_y = self.frame_shape[0]
        x = self._get_lane_x_at_y(lane, bottom_y)
        if x is not None:
            lane_positions.append((x, i))
    
    if lane_positions:
        # 找到最左侧和最右侧的车道
        lane_positions.sort()
        leftmost_idx = lane_positions[0][1]
        rightmost_idx = lane_positions[-1][1]
        
        # 检查最左侧车道是否可能是应急车道
        # 应急车道通常比普通车道窄，或者位于道路边缘
        if len(self.lane_widths) > 0:
            avg_width = np.mean(self.lane_widths)
            # 检查最左侧车道与相邻车道的宽度
            if leftmost_idx < len(self.lane_widths):
                if self.lane_widths[leftmost_idx] > avg_width * self.emergency_lane_width_threshold:
                    # 左侧有较宽的空间，可能是应急车道
                    self.emergency_lane_index = leftmost_idx
                    return
            
            # 检查最右侧车道
            if rightmost_idx > 0 and (rightmost_idx - 1) < len(self.lane_widths):
                if self.lane_widths[rightmost_idx - 1] > avg_width * self.emergency_lane_width_threshold:
                    # 右侧有较宽的空间，可能是应急车道
                    self.emergency_lane_index = rightmost_idx
                    return
        
        # 默认识别最左侧车道为应急车道
        self.emergency_lane_index = leftmost_idx
```

### 2.5 在 VideoProcessorMP.py 中使用配置参数

修改 VideoProcessorMP.py 文件，使用配置参数：

```python
# 在 __init__ 方法中
self.region_update_interval = 5.0  # 区域更新间隔

# 在 run 方法的主循环中
if current_time - self.last_region_update > self.region_generator.region_update_interval and lanes:
    # 生成并更新区域
    if self.region_generator.region_update_enabled:
        self.region_generator.generate_regions(lanes, processed_frame.shape, self.area_manager)
        self.last_region_update = current_time
```

## 3. 配置文件参数说明

| 参数名称 | 默认值 | 作用和影响 |
|---------|-------|-----------|
| generation_interval | 2.0 | 区域生成的时间间隔，避免频繁计算影响性能 |
| region_update_interval | 5.0 | 区域更新的时间间隔，控制更新频率 |
| lane_extension_factor | 10.0 | 车道线延长系数，影响消失点计算的准确性 |
| default_lane_width | 100 | 默认车道宽度，当无法计算车道宽度时使用 |
| emergency_lane_width_threshold | 1.2 | 应急车道宽度阈值，用于识别应急车道 |
| speed_line_count | 5 | 速度检测线数量，影响速度测量的精度 |
| speed_line_spacing_factor | 6 | 速度检测线间距因子，控制速度线的分布密度 |
| region_update_enabled | true | 是否启用区域更新功能 |

## 4. 实现步骤

1. 创建 `Models/Config/lane_based_region_generator_config.json` 配置文件
2. 修改 `lane_based_region_generator.py` 文件，添加配置文件加载功能
3. 修改相关方法，使用配置参数
4. 测试配置文件加载功能，确保默认参数和配置文件参数都能正常工作

## 5. 总结

通过本方案，我们将基于车道线几何关系的区域生成器的重要参数统一配置到配置文件中，实现了参数的集中管理和灵活调整。系统会默认读取配置文件中的参数，如果配置文件中无相关参数则使用默认参数，确保了系统的稳定性和可扩展性。